// # Markdown-Z (MDZ)
const th = @import("./test_helpers.zig");

// Markdown-Z is a variation of Markdown, CommonMark, and its various popular extensions implemented in Zig for WASM. It is designed to produce HTML from a simplified markup language at lightning-fast speeds. It is a self-contained binary that can be ported to any JS runtime that supports Web Assembly 1.0.

// ## Usage

// Browsers:

// ```html
// <!doctype html>
// <script type="module">
//   import { parseMDZ } from "./index.js"; // download from JSR or local build
//   document.body.innerHTML = await parseMDZ("# Hello, world!");
// </script>
// ```

// Deno:

// ```javascript
// import { parseMDZ } from "jsr:@bossley9/mdz@0.6.0";
// console.log(await parseMDZ("# Hello, world!"));
// ```

// Node:

// ```javascript
// import { parseMDZ } from "@bossley9/mdz";
// console.log(await parseMDZ("# Hello, world!"));
// ```

// ## 1. Prelude

// This specification draws inspiration from [CommonMark 0.31.2](https://spec.commonmark.org/0.31.2/), [Github-Flavored Markdown 0.29](https://github.github.com/gfm/), [Markdown-it](https://github.com/markdown-it/markdown-it), and [Djot](https://djot.net/).

// ### 1.1. What is Markdown?

// Markdown is a plain text format for writing structured documents. The goal of Markdown is to provide a human-readable syntax that can be easily transformed into HTML. It was originally created in 2004 by [John Gruber](https://daringfireball.net/projects/markdown/syntax) and has since become relatively standardized by specifications like [CommonMark](https://commonmark.org/) and [Github-Flavored Markdown](https://github.github.com/gfm/). Since its conception, there have been many additions and extensions created for the purpose of furthering Markdown capabilities.

// ### 1.2 Why is Another Spec Needed?

// While CommonMark exists to standardize the original Markdown syntax, the spec is complicated, outdated, and ambiguous. To illustrate this, consider the following examples.

// * Each of the lines below are identical according to CommonMark:
//     ```plaintext
//     text\r\n
//     text\r
//     text\n
//     ```
// * Each of the lines below are identical according to CommonMark:
//     ```plaintext
//     > blockquote
//     >blockquote
//        > blockquote
//     >    blockquote
//     ```
// * Each of the lines below are identical according to CommonMark:
//     ```plaintext
//     ---
//     ***
//     * * *
//     -\t-\t-
//      **  * ** * ** * **
//     -     -      -      -
//     ```
// * There are two ways to write code blocks: [fenced code blocks](https://spec.commonmark.org/0.31.2/#fenced-code-blocks) and [indented code blocks](https://spec.commonmark.org/0.31.2/#indented-code-blocks).
// * There are two ways to write headings: [Setext headings](https://spec.commonmark.org/0.31.2/#setext-headings) and [ATX headings](https://spec.commonmark.org/0.31.2/#atx-headings).
// * Indented code blocks cannot interrupt paragraphs, but paragraphs can interrupt indented code blocks.
// * There are ["tight" and "loose" lists](https://spec.commonmark.org/0.31.2/#loose) depending on the spacing between each line item.
// * Paragraphs (and other blocks) can be indented up to 3 spaces and the leading whitespace will be trimmed, but 4 spaces makes the paragraph a code block.
// * Whitespace is preserved in the middle of text content, but not between blocks or at the start or end of text.
// * Code spans cannot be escaped with a backslash but other inlines can be escaped.

// This specification exists to clarify these edge cases and remove ambiguity.

// This specification is autogenerated from Zig test code to ensure that the test cases in this specification stay in sync with the implementation. Each test case contains a multiline input string and output string. If you're not familiar with Zig, multiline strings begin with `\\` tokens, have no escapes, and can span multiple lines. This best preserves the readability of the inputs and outputs while reading this specification.

// ### 1.3. What is Markdown-Z?

// Markdown-Z attempts to improve upon the flaws and inconsistencies of Markdown and its derivative specifications. This specification heavily reduces the scope and complexity of Markdown to a smart subset of the original CommonMark spec while adding popular extensions that improve Markdown document writing capabilities.

// The core goals of Markdown-Z are the following:

// * Reduced complexity. There should be one and only one syntax to write a each Markdown "block".
// * Modernization. There is no need to support older syntax styles because they holds historical significance.
// * Efficiency. Implementations should be able to parse Markdown-Z documents without backtracking and zero heaps allocations in O(n).
// * WYSIWYG. The CommonMark spec handles whitespace delicately, omitting it in certain scenarios and creating code blocks or nested containers in others. Whitespace should be passed through as is.
// * Close compatibility. Excluding extensions, the markup defined in this document should produce similar output to other CommonMark implementations to preserve relative backwards compatibility with existing Markdown.

// ## 2. Preliminaries

// ### 2.1. Characters, Lines, and Blocks

// All characters are valid in a Markdown-Z document.

// A <dfn>line ending</dfn> is a line feed character (`U+000A`) or a carriage return character (`U+000D`) followed by a line feed character.

// A <dfn>line</dfn> is a sequence of 0 or more characters followed by a line ending.

// A <dfn>blank line</dfn> is a line containing no characters except for the line ending. Blank lines are only used for visual and block separation - multiple consecutive blank lines do not affect the HTML output.

// A <dfn>space</dfn> is `U+0020`.

// A <dfn>block</dfn> is a content type supported by Markdown-Z which transforms into HTML in the output. Usually, blocks are indicated by a unique <dfn>marker</dfn> (special sequence of characters) at the start and/or end of the line.

// ### 2.2. HTML

// Markdown-Z is designed to integrate with HTML. Raw HTML can be written alongside markup. When not in a code block or code span, unescaped characters as passed through as is, meaning no transformation will occur for HTML tags.

// This also means that **no sanitization occurs**. If security is a concern, the output must be sanitized separately.

// ### 2.3. Backslash Escapes

// A backslash character (`U+005C`) escapes the character immediately proceeding it. This means that the following character will be interpreted as literal text and not as a block marker. The backslash character is removed from the final output.

// ```zig
test "2.3.1" {
    const input =
        \\\*not bold\*
    ;
    const output =
        \\<p>*not bold*</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// This means that when `>`, `<` are backslash escaped, they must be translated to ampersand codes to prevent invalid HTML.

// ```zig
test "2.3.2" {
    const input =
        \\\> not a blockquote
    ;
    const output =
        \\<p>&gt; not a blockquote</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "2.3.3" {
    const input =
        \\\<div\> \&gt;
    ;
    const output =
        \\<p>&lt;div&gt; &amp;gt;</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Backslash characters will not appear in the final output unless they are escaped themselves.

// ```zig
test "2.3.4" {
    const input =
        \\foo \\ bar
    ;
    const output =
        \\<p>foo \ bar</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Line endings cannot be escaped.

// ```zig
test "2.3.5" {
    const input =
        \\\Hello, world!\
    ;
    const output =
        \\<p>Hello, world!</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// However, backslash rules are ignored within code blocks.

// ```zig
test "2.3.6" {
    const input =
        \\```zig
        \\const str =
        \\  \\hello,
        \\  \\world!
        \\;
        \\```
    ;
    const output =
        \\<pre><code class="language-zig">const str =
        \\  \\hello,
        \\  \\world!
        \\;
        \\</code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ## 3. Blocks

// The contents of a Markdown-Z document can be divided into three types of content:

// 1. <dfn>Line blocks</dfn>, which dictate how a line (or group of lines) is rendered,
// 1. <dfn>Leaf blocks</dfn>, which are constrained within a particular block, and
// 1. <dfn>Inline content</dfn>.

// Blocks may contain other child blocks, but a leaf block cannot contain a line block. All line blocks must be separated by a blank line.

// Blocks may only be nested up to 16 levels deep. This keeps documents readable and implementations simple.

// ## 4. Line Blocks

// ### 4.1. Block Quotes

// A <dfn>block quote marker</dfn> consists of a `>` character followed by a space followed by content. Block quote markers indicate that the following content should be nested within a block quote.

// ```zig
test "4.1.1" {
    const input =
        \\> hello
    ;
    const output =
        \\<blockquote>
        \\<p>hello</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.1.2" {
    const input =
        \\> # Foo
        \\> bar
        \\> baz
    ;
    const output =
        \\<blockquote>
        \\<h1>Foo</h1>
        \\<p>bar
        \\baz</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Similar to paragraphs, block quotes can lazily continue.

// ```zig
test "4.1.3" {
    const input =
        \\> ## Foo
        \\> 
        \\> bar
        \\> baz
    ;
    const output =
        \\<blockquote>
        \\<h2 id="foo"><a href="#foo">Foo</a></h2>
        \\<p>bar
        \\baz</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.1.4" {
    const input =
        \\> bar
        \\> baz
        \\> foo
    ;
    const output =
        \\<blockquote>
        \\<p>bar
        \\baz
        \\foo</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.1.5" {
    const input =
        \\> foo
        \\> <del>-
    ;
    const output =
        \\<blockquote>
        \\<p>foo
        \\<del>-</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.1.6" {
    const input =
        \\> ```
        \\> foo
        \\> ```
    ;
    const output =
        \\<blockquote>
        \\<pre><code>foo
        \\</code></pre>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// A block quote can be empty.

// ```zig
test "4.1.7" {
    const input =
        \\> 
    ;
    const output =
        \\<blockquote>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.1.8" {
    const input =
        \\> 
        \\>  
        \\> 
    ;
    const output =
        \\<blockquote>
        \\<p> </p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.1.9" {
    const input =
        \\> 
        \\> foo
        \\> 
    ;
    const output =
        \\<blockquote>
        \\<p>foo</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// A blank line must separate block quotes.

// ```zig
test "4.1.10" {
    const input =
        \\> foo
        \\
        \\> bar
    ;
    const output =
        \\<blockquote>
        \\<p>foo</p>
        \\</blockquote>
        \\<blockquote>
        \\<p>bar</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// When we put these block quotes together, we get a single block quote.

// ```zig
test "4.1.11" {
    const input =
        \\> foo
        \\> bar
    ;
    const output =
        \\<blockquote>
        \\<p>foo
        \\bar</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// To get a block quote with two paragraphs:

// ```zig
test "4.1.12" {
    const input =
        \\> foo
        \\> 
        \\> bar
    ;
    const output =
        \\<blockquote>
        \\<p>foo</p>
        \\<p>bar</p>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.1.13" {
    const input =
        \\> bar
        \\
        \\baz
    ;
    const output =
        \\<blockquote>
        \\<p>bar</p>
        \\</blockquote>
        \\<p>baz</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Block quotes can be nested within each other.

// ```zig
test "4.1.14" {
    const input =
        \\> > > foo
        \\
        \\bar
    ;
    const output =
        \\<blockquote>
        \\<blockquote>
        \\<blockquote>
        \\<p>foo</p>
        \\</blockquote>
        \\</blockquote>
        \\</blockquote>
        \\<p>bar</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.1.15" {
    const input =
        \\> > > foo
        \\> 
        \\> bar
        \\> 
        \\> > baz
    ;
    const output =
        \\<blockquote>
        \\<blockquote>
        \\<blockquote>
        \\<p>foo</p>
        \\</blockquote>
        \\</blockquote>
        \\<p>bar</p>
        \\<blockquote>
        \\<p>baz</p>
        \\</blockquote>
        \\</blockquote>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 4.2. Lists

// A <dfn>list</dfn> is a collection of related elements called <dfn>list items</dfn>. Lists begin with a single list item and end when a blank line is reached. Depending on the type of list, a different starting marker may be used:

// * An unordered list item begins with `* `.
// * An ordered list item begins with `1. `.

// Unlike other container blocks, the direct contents of list block items are not wrapped in `<p>` tags.

// ```zig
test "4.2.1" {
    const input =
        \\* Milk
        \\* Eggs
        \\* Yogurt
    ;
    const output =
        \\<ul>
        \\<li>Milk</li>
        \\<li>Eggs</li>
        \\<li>Yogurt</li>
        \\</ul>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// For ordered lists, all indices begin with `1.`. These are auto-incremented in the output.

// ```zig
test "4.2.2" {
    const input =
        \\1. Wake up
        \\1. Go to work
        \\1. Come home
        \\1. Sleep
    ;
    const output =
        \\<ol>
        \\<li>Wake up</li>
        \\<li>Go to work</li>
        \\<li>Come home</li>
        \\<li>Sleep</li>
        \\</ol>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Lazy continuation still applies for list item contents because they act as paragraphs. Lazily continued lines must be indented up to the same level as the starting marker. For unordered lists, this means two spaces. For ordered lists, this means three spaces.

// ```zig
test "4.2.3" {
    const input =
        \\* Chocolate
        \\  Milk
        \\* Eggs
    ;
    const output =
        \\<ul>
        \\<li>Chocolate
        \\Milk</li>
        \\<li>Eggs</li>
        \\</ul>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Other blocks can be started without a new line.

// ```zig
test "4.2.4" {
    const input =
        \\* foo
        \\  
        \\  ```
        \\  code too
        \\  ```
        \\  
        \\  and continuation
        \\* bar
    ;
    const output =
        \\<ul>
        \\<li>foo<pre><code>code too
        \\</code></pre>
        \\and continuation</li>
        \\<li>bar</li>
        \\</ul>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.2.5" {
    const input =
        \\* foo
        \\  
        \\  > quote
        \\  
        \\  *bar*
        \\* baz
    ;
    const output =
        \\<ul>
        \\<li>foo<blockquote>
        \\<p>quote</p>
        \\</blockquote>
        \\<em>bar</em></li>
        \\<li>baz</li>
        \\</ul>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.2.6" {
    const input =
        \\* lazy
        \\  line
        \\  continuation
        \\* works
    ;
    const output =
        \\<ul>
        \\<li>lazy
        \\line
        \\continuation</li>
        \\<li>works</li>
        \\</ul>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "4.2.7" {
    const input =
        \\* no html blocks directly in lists,
        \\* <div>inline</div> **content**
        \\* only
    ;
    const output =
        \\<ul>
        \\<li>no html blocks directly in lists,</li>
        \\<li><div>inline</div> <strong>content</strong></li>
        \\<li>only</li>
        \\</ul>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ## 5. Leaf Blocks

// ### 5.1. Paragraphs

// A paragraph is a block that cannot be interpreted as any other kind of block. A paragraph can contain inline content.

// ```zig
test "5.1.1" {
    const input =
        \\Hello, world!
    ;
    const output =
        \\<p>Hello, world!</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.1.2" {
    const input =
        \\aaa
        \\
        \\bbb
    ;
    const output =
        \\<p>aaa</p>
        \\<p>bbb</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Paragraphs "lazily" continue to the next line when a blank line does not separate the lines.

// ```zig
test "5.1.3" {
    const input =
        \\aaa
        \\bbb
        \\
        \\ccc
        \\ddd
    ;
    const output =
        \\<p>aaa
        \\bbb</p>
        \\<p>ccc
        \\ddd</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.1.4" {
    const input =
        \\foo
        \\\*bar
        \\
        \\baz
        \\foo\*
    ;
    const output =
        \\<p>foo
        \\*bar</p>
        \\<p>baz
        \\foo*</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Multiple blank lines have no effect.

// ```zig
test "5.1.5" {
    const input =
        \\aaa
        \\
        \\
        \\
        \\bbb
    ;
    const output =
        \\<p>aaa</p>
        \\<p>bbb</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Whitespace and newlines are preserved in the final output.

// ```zig
test "5.1.6" {
    const input =
        \\  aaa
        \\ bbb
    ;
    const output =
        \\<p>  aaa
        \\ bbb</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.1.7" {
    const input =
        \\  
        \\
        \\aaa
        \\  
        \\
        \\# aaa
        \\
        \\  
    ;
    const output =
        \\<p>  </p>
        \\<p>aaa
        \\  </p>
        \\<h1>aaa</h1>
        \\<p>  </p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 5.2. Code Blocks

// A <dfn>code fence</dfn> is a sequence of three consecutive backtick characters. A code block begins with a code fence and ends with code fence. The opening code block line may optionally contain text immediately following the backtick characters. This text is called the <dfn>info string</dfn> and may not contain any non-alphabetic characters.

// The content of a code block may span multiple lines until the ending code fence is reached. The contents of a code block are treated as literal text, not inline content. In implementation, `<`, `>`, and `&` must be converted to `&lt;`, `&gt;`, and `&amp;` respectively to avoid conflicts with generated HTML markup.

// ```zig
test "5.2.1" {
    const input =
        \\```
        \\<
        \\ >
        \\```
    ;
    const output =
        \\<pre><code>&lt;
        \\ &gt;
        \\</code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.2.2" {
    const input =
        \\```
        \\aaa
        \\---
        \\```
    ;
    const output =
        \\<pre><code>aaa
        \\---
        \\</code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Excluding the info string, the opening and closing code fences must be exactly 3 backticks long.

// ```zig
test "5.2.3" {
    const input =
        \\```
        \\content
        \\```
    ;
    const output =
        \\<pre><code>content
        \\</code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Unclosed code blocks are closed by the end of the document or parent block:

// ```zig
test "5.2.4" {
    const input =
        \\```
    ;
    const output =
        \\<pre><code></code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.2.5" {
    const input =
        \\```
        \\aaa
    ;
    const output =
        \\<pre><code>aaa
        \\</code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.2.6" {
    const input =
        \\> ```
        \\> aaa
        \\
        \\bbb
    ;
    const output =
        \\<blockquote>
        \\<pre><code>aaa
        \\</code></pre>
        \\</blockquote>
        \\<p>bbb</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// A code block can have blank lines or no content:

// ```zig
test "5.2.7" {
    const input =
        \\```
        \\
        \\
        \\```
    ;
    const output =
        \\<pre><code>
        \\
        \\</code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.2.8" {
    const input =
        \\```
        \\```
    ;
    const output =
        \\<pre><code></code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Fences cannot be indented:

// ```zig
test "5.2.9" {
    const input =
        \\ ```
        \\ aaa
        \\aaa
        \\```
    ;
    const output =
        \\<p> <code></code><code>
        \\ aaa
        \\aaa
        \\</code><code></code></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// The info string is used to specify the programming language of the code block and is rendered in the `class` attribute of the code string with prefix `language-` in accordance with the [WhatWG recommendation](https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-code-element).

// ```zig
test "5.2.10" {
    const input =
        \\```ruby
        \\def foo(x)
        \\  return 3
        \\end
        \\```
    ;
    const output =
        \\<pre><code class="language-ruby">def foo(x)
        \\  return 3
        \\end
        \\</code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.2.11" {
    const input =
        \\```javascript
        \\```
    ;
    const output =
        \\<pre><code class="language-javascript"></code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// An info string of "plaintext" is ignored.

// ```zig
test "5.2.12" {
    const input =
        \\```plaintext
        \\aaa
        \\```
    ;
    const output =
        \\<pre><code>aaa
        \\</code></pre>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 5.3. Headings

// Headings begin at the start of a block and consist of 1 to 6 `#` characters followed by exactly one space followed by inline content. The heading level is equal to the number of `#` characters. Headings only span a single line.

// ```zig
test "5.3.1" {
    const input =
        \\# foo
        \\
        \\## foo
        \\
        \\### foo
        \\
        \\#### foo
        \\
        \\##### foo
        \\
        \\###### foo
    ;
    const output =
        \\<h1>foo</h1>
        \\<h2 id="foo"><a href="#foo">foo</a></h2>
        \\<h3 id="foo"><a href="#foo">foo</a></h3>
        \\<h4 id="foo"><a href="#foo">foo</a></h4>
        \\<h5 id="foo"><a href="#foo">foo</a></h5>
        \\<h6 id="foo"><a href="#foo">foo</a></h6>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// More than six # characters is not a heading:

// ```zig
test "5.3.2" {
    const input =
        \\####### foo
    ;
    const output =
        \\<p>####### foo</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Exactly one space is required between the `#` characters and the heading's contents.

// ```zig
test "5.3.3" {
    const input =
        \\#5 bolt
        \\
        \\#hashtag
    ;
    const output =
        \\<p>#5 bolt</p>
        \\<p>#hashtag</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// This is not a heading because the first `#` is escaped:

// ```zig
test "5.3.4" {
    const input =
        \\\## foo
    ;
    const output =
        \\<p>## foo</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Contents are parsed as inlines.

// ```zig
test "5.3.5" {
    const input =
        \\## foo *bar* \*baz\*
    ;
    const output =
        \\<h2 id="foo-bar-baz"><a href="#foo-bar-baz">foo <em>bar</em> *baz*</a></h2>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Indentation is not allowed.

// ```zig
test "5.3.6" {
    const input =
        \\ ### foo
    ;
    const output =
        \\<p> ### foo</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.3.7" {
    const input =
        \\foo
        \\    # bar
    ;
    const output =
        \\<p>foo
        \\    # bar</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Headings must be separated from surrounding content by blank lines.

// ```zig
test "5.3.8" {
    const input =
        \\---
        \\
        \\# foo
        \\
        \\---
    ;
    const output =
        \\<hr />
        \\<h1>foo</h1>
        \\<hr />
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.3.9" {
    const input =
        \\Foo bar
        \\# baz
        \\Bar foo
    ;
    const output =
        \\<p>Foo bar
        \\# baz
        \\Bar foo</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Headings can only span one line. They do not lazily continue.

// ```zig
test "5.3.10" {
    const input =
        \\# Hello
        \\world!
    ;
    const output =
        \\<h1>Hello</h1>
        \\<p>world!</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Headings other than <h1>s are automatically wrapped in links with slug identifiers. However, there is no check for slug uniqueness - it is the responsibility of the user to ensure that there are no identical slug conflicts.

// ```zig
test "5.3.11" {
    const input =
        \\# Hello, world!
        \\
        \\## Hello, world!
    ;
    const output =
        \\<h1>Hello, world!</h1>
        \\<h2 id="hello-world"><a href="#hello-world">Hello, world!</a></h2>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 5.4. Thematic Breaks

// A thematic break is a line consisting of exactly three `-` characters.

// ```zig
test "5.4.1" {
    const input =
        \\---
    ;
    const output =
        \\<hr />
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.4.2" {
    const input =
        \\--
    ;
    const output =
        \\<p><del></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Like other blocks, thematic breaks require blank lines as separation from other blocks.

// ```zig
test "5.4.3" {
    const input =
        \\foo
        \\---
        \\bar
    ;
    const output =
        \\<p>foo
        \\<del>-
        \\bar</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 5.5. HTML Blocks

// Similar to a code block, an HTML block is a block that is treated as literal text. The key differences are that HTML markup markers (`<`, `>`, and `&`) are not escaped, and that an HTML block ends when a blank line is reached.

// An HTML block begins with a `<` character immediately followed by any alphabetic character.

// ```zig
test "5.5.1" {
    const input =
        \\<div>foo</div>
    ;
    const output =
        \\<div>foo</div>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.5.2" {
    const input =
        \\<p>custom</p>
        \\<p>HTML elements</p>
        \\<p>here</p>
    ;
    const output =
        \\<p>custom</p>
        \\<p>HTML elements</p>
        \\<p>here</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// In HTML blocks, leading and trailing spaces are trimmed from lines.

// ```zig
test "5.5.3" {
    const input =
        \\# foo
        \\
        \\<details>
        \\  <summary>open</summary>
        \\  secrets      
        \\</details>
        \\
        \\foo bar
    ;
    const output =
        \\<h1>foo</h1>
        \\<details>
        \\<summary>open</summary>
        \\secrets
        \\</details>
        \\<p>foo bar</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 5.6. Tables

// A table is an arrangement of data with rows and columns, consisting of a header row, a delimiter row separating the header from the data, and zero or more data rows. Within a row, each column is separated by pipes (`|`) and exactly one space character of padding for column contents. The delimiter row consists of cells whose contents are only hyphens (`-`). Unlike Github-Flavored Markdown, no column alignment symbols exist. The contents of each cell is parsed as inlines.

// ```zig
test "5.6.1" {
    const input =
        \\| col 1 | col 2 |
        \\| ------ | ------ |
        \\| data 1 | data 2 |
    ;
    const output =
        \\<table>
        \\<thead>
        \\<tr>
        \\<th>col 1</th>
        \\<th>col 2</th>
        \\</tr>
        \\</thead>
        \\<tbody>
        \\<tr>
        \\<td>data 1</td>
        \\<td>data 2</td>
        \\</tr>
        \\</tbody>
        \\</table>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "5.6.2" {
    const input =
        \\| *important* | col 2 |
        \\| ------ | ------ |
        \\| 1 | `data here` |
    ;
    const output =
        \\<table>
        \\<thead>
        \\<tr>
        \\<th><em>important</em></th>
        \\<th>col 2</th>
        \\</tr>
        \\</thead>
        \\<tbody>
        \\<tr>
        \\<td>1</td>
        \\<td><code>data here</code></td>
        \\</tr>
        \\</tbody>
        \\</table>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ## 6. Inline Content

// Inline content is parsed after block structure is determined. Inline content is parsed character by character - that is, inlines do not self-close unlike blocks. It is the responsibilty of the writer to ensure that every inline content marker is properly closed. Additionally, all inlines depend on specific marker characters (`[`, `]`, `` ` ``, `*`, `\\`) that must be escaped. Non-escaped marker characters may lead to undefined behavior.

// ### 6.1. Strong and Emphasis

// An asterisk character (`*`) in inline content is candidate to become either `<strong>` or `<em>`. The plain text must be wrapped with a single opening and closing asterisk character for the text to become emphasized. To make the text strong, the plain text must be wrapped in two opening and closing asterisks.

// ```zig
test "6.1.1" {
    const input =
        \\Hello, *world*! **strong here**
    ;
    const output =
        \\<p>Hello, <em>world</em>! <strong>strong here</strong></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.1.2" {
    const input =
        \\*foo* *bar*
    ;
    const output =
        \\<p><em>foo</em> <em>bar</em></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.1.3" {
    const input =
        \\*hello\* world*
    ;
    const output =
        \\<p><em>hello* world</em></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.1.4" {
    const input =
        \\foo*bar*
    ;
    const output =
        \\<p>foo<em>bar</em></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Nesting inlines is possible.

// ```zig
test "6.1.5" {
    const input =
        \\*foo **bar** baz*
    ;
    const output =
        \\<p><em>foo <strong>bar</strong> baz</em></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 6.2. Code Spans

// A code span begins and ends with a single backtick character and represents an inline segment of code. Any inline content within the code span is treated as literal text excluding backslashes. Any raw HTML within a code span will be escaped.

// ```zig
test "6.2.1" {
    const input =
        \\foo `bar`
    ;
    const output =
        \\<p>foo <code>bar</code></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.2.2" {
    const input =
        \\foo `<div>` bar
    ;
    const output =
        \\<p>foo <code>&lt;div&gt;</code> bar</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// If a literal backtick needs to be typed within the code span, it can be escaped with a backslash.

// ```zig
test "6.2.3" {
    const input =
        \\the backtick character is `\``.
    ;
    const output =
        \\<p>the backtick character is <code>`</code>.</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 6.3. Links

// Links begin with a `[` starting marker, a `](` middle marker and end with a `)` marker. The content between the first two markers represents the link alt text while the content between the last two markers represents the link URI. All of these markers are required, including a non-empty link alt text and link URI. Links cannot span multiple lines even with lazy continuation.

// ```zig
test "6.3.1" {
    const input =
        \\[link here](https://example.com)
    ;
    const output =
        \\<p><a href="https://example.com">link here</a></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.3.2" {
    const input =
        \\here's [*emphasis* and `code` within a link](https://example.com)
    ;
    const output =
        \\<p>here's <a href="https://example.com"><em>emphasis</em> and <code>code</code> within a link</a></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.3.3" {
    const input =
        \\an \[escaped\](link)
    ;
    const output =
        \\<p>an [escaped](link)</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.3.4" {
    const input =
        \\[link 1](https://example.com) and [link 2](https://example2.com)
    ;
    const output =
        \\<p><a href="https://example.com">link 1</a> and <a href="https://example2.com">link 2</a></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.3.5" {
    const input =
        \\link with [`literal \]\( symbols`](https://xyz.xyz) in the alt text
    ;
    const output =
        \\<p>link with <a href="https://xyz.xyz"><code>literal ]( symbols</code></a> in the alt text</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 6.4. Footnotes

// Footnotes are comprised of two parts: the footnote citation embedded in content and the footnote reference itself. Footnote citations can be considered inline content while footnote references can be considered leaf blocks.

// A footnote citation begins with `[^`, contains a reference number, then ends with a `]` character. A footnote reference starts on its own line and begins with `[^`, contains a matching reference number, then uses a `]: ` marker to indicate the reference content may start. Markdown-Z performs no checking to ensure that references are all accounted for - it is the responsibility of the user to ensure that all references use the same characters to link to each other.

// A footnote citation reference number must be between 0 and 127. Inline content is not allowed within a footnote citation, but it is allowed within a footnote reference.

// ```zig
test "6.4.1" {
    const input =
        \\If you're referring to the incident with the dragon[^1], I was barely involved.
        \\
        \\[^1]: Gandalf was heavily involved.
    ;
    const output =
        \\<p>If you're referring to the incident with the dragon<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>, I was barely involved.</p>
        \\<section class="footnotes">
        \\<ol class="footnotes-list">
        \\<li id="fn1" class="footnote-item"><p>Gandalf was heavily involved. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li>
        \\</ol>
        \\</section>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.4.2" {
    const input =
        \\Dangling citations[^1] are not an error[^2].
    ;
    const output =
        \\<p>Dangling citations<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> are not an error<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.4.3" {
    const input =
        \\The same ref[^1] may be used twice[^1].
    ;
    const output =
        \\<p>The same ref<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> may be used twice<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>.</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.4.4" {
    const input =
        \\[^1]: A footnote reference by itself
    ;
    const output =
        \\<section class="footnotes">
        \\<ol class="footnotes-list">
        \\<li id="fn1" class="footnote-item"><p>A footnote reference by itself</p></li>
        \\</ol>
        \\</section>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// Footnote references will be grouped together in the same footnote reference block.

// ```zig
test "6.4.5" {
    const input =
        \\one[^1] two[^2].
        \\
        \\[^1]: footnote 1
        \\[^2]: footnote 2
    ;
    const output =
        \\<p>one<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> two<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>.</p>
        \\<section class="footnotes">
        \\<ol class="footnotes-list">
        \\<li id="fn1" class="footnote-item"><p>footnote 1 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li>
        \\<li id="fn2" class="footnote-item"><p>footnote 2 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li>
        \\</ol>
        \\</section>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.4.6" {
    const input =
        \\used[^1] twice[^1].
        \\
        \\[^1]: footnote
    ;
    const output =
        \\<p>used<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> twice<sup class="footnote-ref"><a href="#fn1" id="fnref1:1">[1:1]</a></sup>.</p>
        \\<section class="footnotes">
        \\<ol class="footnotes-list">
        \\<li id="fn1" class="footnote-item"><p>footnote <a href="#fnref1" class="footnote-backref">↩︎</a> <a href="#fnref1:1" class="footnote-backref">↩︎</a></p></li>
        \\</ol>
        \\</section>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.4.7" {
    const input =
        \\quote[^1]
        \\
        \\[^1]: references may contain `inline content`.
    ;
    const output =
        \\<p>quote<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
        \\<section class="footnotes">
        \\<ol class="footnotes-list">
        \\<li id="fn1" class="footnote-item"><p>references may contain <code>inline content</code>. <a href="#fnref1" class="footnote-backref">↩︎</a></p></li>
        \\</ol>
        \\</section>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 6.5. Images

// Images are identical in syntax to links save the starting marker, which begins with `![`. The content between the first two markers represents the image alt text while the content between the last two markers represents the image URI. Images cannot span multiple lines even with lazy continuation. One key distinction between links and images i s that image alt text cannot contain inline content. All image alt text symbols must be backslash escaped except quotes, which are automatically escaped.

// ```zig
test "6.5.1" {
    const input =
        \\![my dog](https://example.com/dog.jpg)
    ;
    const output =
        \\<p><img alt="my dog" src="https://example.com/dog.jpg" /></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.5.2" {
    const input =
        \\my face looks like ![portrait](https://example.com/me.jpg) and looks beautiful
    ;
    const output =
        \\<p>my face looks like <img alt="portrait" src="https://example.com/me.jpg" /> and looks beautiful</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.5.3" {
    const input =
        \\![escaping symbols like \* and \[ in alt](https://example.com/img.png)
    ;
    const output =
        \\<p><img alt="escaping symbols like * and [ in alt" src="https://example.com/img.png" /></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ```zig
test "6.5.4" {
    const input =
        \\!["quotes" are escaped.](https://example.com/img.png)
    ;
    const output =
        \\<p><img alt="&quot;quotes&quot; are escaped." src="https://example.com/img.png" /></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 6.6. Strikethroughs

// A strikethrough represents a removal of outdated content that may no longer be accurate or relevant. It is started and ended with the `~~` marker.

// ```zig
test "6.6.1" {
    const input =
        \\Tomorrow is ~~Tuesday~~ Wednesday.
    ;
    const output =
        \\<p>Tomorrow is <s>Tuesday</s> Wednesday.</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 6.7. Insertions and Deletions

// Insertions and deletions can be used to indicate that some content was removed or added after creation. Insertions start and end with the `++` marker, while deletions start and end with the `--` marker.

// ```zig
test "6.7.1" {
    const input =
        \\--yesterday--today++tomorrow++
    ;
    const output =
        \\<p><del>yesterday</del>today<ins>tomorrow</ins></p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```

// ### 6.8. Highlighted Text

// Highlighted text is highlighted in HTML and can be used to emphasize text. Highlighted text starts and end with the `== marker.

// ```zig
test "6.8.1" {
    const input =
        \\foo ==bar== baz
    ;
    const output =
        \\<p>foo <mark>bar</mark> baz</p>
    ;
    try th.expectParseMDZ(input, output);
}
// ```
