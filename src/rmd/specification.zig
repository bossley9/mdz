// # Refined Markdown Spec
const th = @import("./test_helpers.zig");

// <small>
//   This specification is based loosely on the <a href="https://spec.commonmark.org/0.31.2/">CommonMark 0.31.2 specification</a> and draws inspiration from the <a href="https://github.github.com/gfm/">Github-Flavored Markdown 0.29 specification</a> and from the <a href="https://github.com/markdown-it/markdown-it">markdown-it</a> library and its various extensions.
// </small>

// ## 1. Prelude

// ### 1.1. What is Markdown?

// Markdown is a plain text format for writing structured documents. The goal of Markdown is to provide a human-readable syntax that can be easily transformed into HTML. It was originally created in 2004 by [John Gruber](https://daringfireball.net/projects/markdown/syntax) and has since become relatively standardized by specifications like [CommonMark](https://commonmark.org/) and [Github-Flavored Markdown](https://github.github.com/gfm/). Since its conception, there have been many additions and extensions created for the purpose of furthering Markdown capabilities.

// ### 1.2 Why is Another Spec Needed?

// While CommonMark exists to standardize the original Markdown syntax, the spec is complicated, outdated, and ambiguous. To illustrate this, consider the following examples.
//
// * Each of the lines below are identical according to CommonMark:
//     ```plaintext
//     text\r\n
//     text\r
//     text\n
//     ```
// * Each of the lines below are identical according to CommonMark:
//     ```plaintext
//     > blockquote
//     >blockquote
//        > blockquote
//     >    blockquote
//     ```
// * Each of the lines below are identical according to CommonMark:
//     ```plaintext
//     ---
//     ***
//     * * *
//     -\t-\t-
//      **  * ** * ** * **
//     -     -      -      -
//     ```
// * There are two ways to write code blocks: fenced code blocks and indented code blocks.
// * There are two ways to write headings: Setext headings and ATX headings.
// * Indented code blocks cannot interrupt paragraphs, but paragraphs can interrupt indented code blocks.
// * There are "tight" and "loose" lists depending on the spacing between each line item.
// * Paragraphs (and other blocks) can be indented up to 3 spaces and the leading whitespace will be trimmed, but 4 spaces makes the paragraph a code block.

// This specification exists to clarify these edge cases and remove ambiguity.

// This specification is autogenerated from Zig test code to ensure test cases stay in sync with the implementation. Each test case contains a multiline input string and output string. If you're not familiar with Zig, multiline strings begin with `\\` tokens, have no escapes, and can span multiple lines. This best preserves the readability of the inputs and outputs.

// ### 1.3. What is Refined Markdown?

// Refined Markdown (RMD) attempts to improve upon the CommonMark specification. This specification heavily reduces the scope and complexity of Markdown to a smart subset of the original CommonMark spec while adding popular extensions that improves Markdown document writing capabilities for the purpose of HTML conversion.

// The core goals of Refined Markdown are the following:

// * Reduced complexity. There should only be one syntax to write a Refined Markdown block.
// * Modernization. There is no need to support an older syntax style because it holds historical significance.
// * Efficiency. Implementations should be able to parse Refined Markdown without backtracking in O(n).
// * WYSIWYG. The CommonMark spec handles whitespace delicately, omitting it in certain scenarios and creating code blocks or nested containers in others. Whitespace should be passed through as is.
// * Close compatibility. Excluding extensions, the markup defined in this document should produce similar output to other CommonMark implementations to preserve relative backwards compatibility with existing Markdown.

// ## 2. Preliminaries

// ### 2.1. Characters and Lines

// Any characters are valid in a Refined Markdown document.

// A <dfn>line</dfn> is a sequence of 0 or more characters followed by a line ending.

// A <dfn>line ending</dfn> is a line feed (`U+000A`) or a carriage return (`U+000D`) followed by a line ending.

// A <dfn>space</dfn> is `U+0020`.

// ### 2.2. HTML

// Refined Markdown is designed to integrate with HTML. Raw HTML can be written alongside Refined Markdown. When parsing HTML blocks, they will be passed through and outputted as is. No transformation is necessary for raw HTML blocks.

// This also means that *Refined Markdown performs no sanitization*. If security is a concern, the output HTML will need to be sanitized separately.

// ### 2.3. Backslash Escapes

// A backslash character which precedes another character means that the character will be interpreted as text and not as a block or inline marker. The backslash character is removed from the final output.

// ```zig
test "2.3.1" {
    const input =
        \\\*not bold\*
    ;
    const output =
        \\<p>*not bold*</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// This means that when `>`, `<` are backslash escaped, they must be translated to ampersand codes to prevent invalid HTML.

// ```zig
test "2.3.2" {
    const input =
        \\\> not a blockquote
    ;
    const output =
        \\<p>&gt; not a blockquote</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Backslash characters will not appear in the HTML output unless they are escaped.

// ```zig
test "2.3.3" {
    const input =
        \\My name is \\ John.
    ;
    const output =
        \\<p>My name is \ John.</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "2.3.4" {
    const input =
        \\\Hello, world!\
    ;
    const output =
        \\<p>Hello, world!</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// However, backslash rules are ignored within code blocks.

// ```zig
test "2.3.5" {
    const input =
        \\```zig
        \\const str =
        \\  \\hello,
        \\  \\world!
        \\;
        \\```
    ;
    const output =
        \\<pre><code class="language-zig">const str =
        \\  \\hello,
        \\  \\world!
        \\;
        \\</code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ## 3. Blocks and Inlines

// The content of a Refined Markdown document is divided into blocks and inlines. <dfn>Blocks</dfn> are structural elements which may contain nested blocks within them, while <dfn>inlines</dfn> are text elements which affect styling. All blocks require a blank line separating each block with the exception of list items. Leaf blocks cannot contain other blocks while container blocks may contain child blocks. In the event of a conflict, blocks structure always takes precedence over inline structure.

// ## 4. Leaf Blocks

// ### 4.1. Blank Lines

// A blank line is a line containing no text. Blank lines are ignored in output but indicate that the previous block(s) should be closed.

// ```zig
test "4.1.1" {
    const input =
        \\
        \\
        \\aaa
        \\
        \\
        \\# aaa
        \\
        \\
    ;
    const output =
        \\<p>aaa</p>
        \\<h1>aaa</h1>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ### 4.2. Paragraphs

// A paragraph is a block that cannot be interpreted as any other kind of block. A paragraph can contain inlines.

// ```zig
test "4.2.1" {
    const input =
        \\Hello, world!
    ;
    const output =
        \\<p>Hello, world!</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.2.2" {
    const input =
        \\aaa
        \\
        \\bbb
    ;
    const output =
        \\<p>aaa</p>
        \\<p>bbb</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Paragraphs can "lazily" continue to the next line.

// ```zig
test "4.2.3" {
    const input =
        \\aaa
        \\bbb
        \\
        \\ccc
        \\ddd
    ;
    const output =
        \\<p>aaa
        \\bbb</p>
        \\<p>ccc
        \\ddd</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Multiple blank lines have no effect.

// ```zig
test "4.2.4" {
    const input =
        \\aaa
        \\
        \\
        \\
        \\bbb
    ;
    const output =
        \\<p>aaa</p>
        \\<p>bbb</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Whitespace (and newlines) are preserved.

// ```zig
test "4.2.5" {
    const input =
        \\  aaa
        \\ bbb
    ;
    const output =
        \\<p>  aaa
        \\ bbb</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.2.6" {
    const input =
        \\  
        \\
        \\aaa
        \\  
        \\
        \\# aaa
        \\
        \\  
    ;
    const output =
        \\<p>  </p>
        \\<p>aaa
        \\  </p>
        \\<h1>aaa</h1>
        \\<p>  </p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ### 4.3. Thematic Breaks

// Thematic break consists of three or more matching `-` characters at the beginning of a line.

// ```zig
test "4.3.1" {
    const input =
        \\---
    ;
    const output =
        \\<hr />
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.3.2" {
    const input =
        \\--
    ;
    const output =
        \\<p>--</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// More than three characters may be used.

// ```zig
test "4.3.3" {
    const input =
        \\---------------------------------
    ;
    const output =
        \\<hr />
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Like other blocks, thematic breaks require blank lines as separation from other blocks.

// ```zig
test "4.3.4" {
    const input =
        \\foo
        \\---
        \\bar
    ;
    const output =
        \\<p>foo
        \\---
        \\bar</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ### 4.4. Headings

// Headings begin at the start of a line and consist of 1 to 6 `#` characters followed by exactly one space followed by inlines. The heading level is equal to the number of `#` characters. Headings can only span one line.

// ```zig
test "4.4.1" {
    const input =
        \\# foo
        \\
        \\## foo
        \\
        \\### foo
        \\
        \\#### foo
        \\
        \\##### foo
        \\
        \\###### foo
    ;
    const output =
        \\<h1>foo</h1>
        \\<h2>foo</h2>
        \\<h3>foo</h3>
        \\<h4>foo</h4>
        \\<h5>foo</h5>
        \\<h6>foo</h6>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// More than six # characters is not a heading:

// ```zig
test "4.4.2" {
    const input =
        \\####### foo
    ;
    const output =
        \\<p>####### foo</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Exactly one space is required between the `#` characters and the heading's contents.

// ```zig
test "4.4.3" {
    const input =
        \\#5 bolt
        \\
        \\#hashtag
    ;
    const output =
        \\<p>#5 bolt</p>
        \\<p>#hashtag</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// This is not a heading because the first `#` is escaped:

// ```zig
test "4.4.4" {
    const input =
        \\\## foo
    ;
    const output =
        \\<p>## foo</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Contents are parsed as inlines.

// TODO inlines
// ```zig
// test "4.4.5" {
//     const input =
//         \\# foo *bar* \*baz\*
//     ,
//         \\<h1>foo <em>bar</em> *baz*</h1>
//     ;try th.expectParseRMD(input, output);
// }
// ```

// Indentation is not allowed.

// ```zig
test "4.4.6" {
    const input =
        \\ ### foo
    ;
    const output =
        \\<p> ### foo</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.4.7" {
    const input =
        \\foo
        \\    # bar
    ;
    const output =
        \\<p>foo
        \\    # bar</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Headings must be separated from surrounding content by blank lines.

// ```zig
test "4.4.8" {
    const input =
        \\---
        \\
        \\## foo
        \\
        \\---
    ;
    const output =
        \\<hr />
        \\<h2>foo</h2>
        \\<hr />
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.4.9" {
    const input =
        \\Foo bar
        \\# baz
        \\Bar foo
    ;
    const output =
        \\<p>Foo bar
        \\# baz
        \\Bar foo</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Headings can only span one line. They do not lazily continue.

// ```zig
test "4.4.10" {
    const input =
        \\# Hello
        \\world!
    ;
    const output =
        \\<h1>Hello</h1>
        \\<p>world!</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ### 4.5. Code Blocks

// A <dfn>code fence</dfn> is a sequence of three consecutive backtick characters. A code block begins with a code fence and ends with code fence. The opening code block line may optionally contain text immediately following the backtick characters. This text is called the <dfn>info string</dfn> and may not contain any non-alphabetic characters.

// The content of a code block may span multiple lines until the ending code fence is reached. The contents of a code block are treated as literal text, not inlines. In implementation, `<`, `>`, and `&` must be converted to `&lt;`, `&gt;`, and `&amp;` respectively to avoid conflicts with generated HTML markup.

// ```zig
test "4.5.1" {
    const input =
        \\```
        \\<
        \\ >
        \\```
    ;
    const output =
        \\<pre><code>&lt;
        \\ &gt;
        \\</code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.5.2" {
    const input =
        \\```
        \\aaa
        \\~~~
        \\```
    ;
    const output =
        \\<pre><code>aaa
        \\~~~
        \\</code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// The opening and closing code fences must be exactly 3 backticks long (excluding the info string):

// ```zig
test "4.5.3" {
    const input =
        \\```
        \\content
        \\```
    ;
    const output =
        \\<pre><code>content
        \\</code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Unclosed code blocks are closed by the end of the document or parent block:

// ```zig
test "4.5.4" {
    const input =
        \\```
    ;
    const output =
        \\<pre><code></code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.5.5" {
    const input =
        \\```
        \\aaa
    ;
    const output =
        \\<pre><code>aaa
        \\</code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.5.6" {
    const input =
        \\> ```
        \\> aaa
        \\
        \\bbb
    ;
    const output =
        \\<blockquote>
        \\<pre><code>aaa
        \\</code></pre>
        \\</blockquote>
        \\<p>bbb</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// A code block can have blank lines or no content:

// ```zig
test "4.5.7" {
    const input =
        \\```
        \\
        \\
        \\```
    ;
    const output =
        \\<pre><code>
        \\
        \\</code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.5.8" {
    const input =
        \\```
        \\```
    ;
    const output =
        \\<pre><code></code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Fences cannot be indented:

// ```zig
test "4.5.9" {
    const input =
        \\ ```
        \\ aaa
        \\aaa
        \\```
    ;
    const output =
        \\<p> ```
        \\ aaa
        \\aaa
        \\```</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// The info string is used to specify the programming language of the code block and is rendered in the `class` attribute of the code string with prefix `language-` in accordance with the [WhatWG recommendation](https://html.spec.whatwg.org/multipage/text-level-semantics.html#the-code-element).

// ```zig
test "4.5.10" {
    const input =
        \\```ruby
        \\def foo(x)
        \\  return 3
        \\end
        \\```
    ;
    const output =
        \\<pre><code class="language-ruby">def foo(x)
        \\  return 3
        \\end
        \\</code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "4.5.11" {
    const input =
        \\```;
        \\```
    ;
    const output =
        \\<pre><code class="language-;"></code></pre>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ## 5. Container Blocks

// ### 5.1. Block Quotes

// A <dfn>block quote marker</dfn> consists of either a `>` character followed by one space followed by content, or a single `>` character followed by a line ending. Block quote markers indicate that the following content should be nested within a block quote.

// ```zig
test "5.1.1" {
    const input =
        \\> hello
    ;
    const output =
        \\<blockquote>
        \\<p>hello</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "5.1.2" {
    const input =
        \\> # Foo
        \\> bar
        \\> baz
    ;
    const output =
        \\<blockquote>
        \\<h1>Foo</h1>
        \\<p>bar
        \\baz</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Similar to paragraphs, block quotes can lazily continue.

// ```zig
test "5.1.3" {
    const input =
        \\> # Foo
        \\> bar
        \\baz
    ;
    const output =
        \\<blockquote>
        \\<h1>Foo</h1>
        \\<p>bar
        \\baz</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "5.1.4" {
    const input =
        \\> bar
        \\baz
        \\> foo
    ;
    const output =
        \\<blockquote>
        \\<p>bar
        \\baz
        \\foo</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// Laziness always applies to lines that would have been continuations of paragraphs had they been prepended with block quote markers.

// ```zig
test "5.1.5" {
    const input =
        \\> foo
        \\---
    ;
    const output =
        \\<blockquote>
        \\<p>foo
        \\---</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "5.1.6" {
    const input =
        \\> ```
        \\foo
        \\```
    ;
    const output =
        \\<blockquote>
        \\<pre><code>foo
        \\</code></pre>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// A block quote can be empty.

// ```zig
test "5.1.7" {
    const input =
        \\>
    ;
    const output =
        \\<blockquote>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "5.1.8" {
    const input =
        \\>
        \\>  
        \\> 
    ;
    const output =
        \\<blockquote>
        \\<p> </p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "5.1.9" {
    const input =
        \\>
        \\> foo
        \\> 
    ;
    const output =
        \\<blockquote>
        \\<p>foo</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// A blank line must separate block quotes.

// ```zig
test "5.1.10" {
    const input =
        \\> foo
        \\
        \\> bar
    ;
    const output =
        \\<blockquote>
        \\<p>foo</p>
        \\</blockquote>
        \\<blockquote>
        \\<p>bar</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// When we put these block quotes together, we get a single block quote.

// ```zig
test "5.1.11" {
    const input =
        \\> foo
        \\> bar
    ;
    const output =
        \\<blockquote>
        \\<p>foo
        \\bar</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// To get a block quote with two paragraphs:

// ```zig
test "5.1.12" {
    const input =
        \\> foo
        \\> 
        \\> bar
    ;
    const output =
        \\<blockquote>
        \\<p>foo</p>
        \\<p>bar</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// A blank line between a block quote and a paragraph prevents lazy continuing.

// ```zig
test "5.1.13" {
    const input =
        \\> bar
        \\baz
    ;
    const output =
        \\<blockquote>
        \\<p>bar
        \\baz</p>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "5.1.14" {
    const input =
        \\> bar
        \\
        \\baz
    ;
    const output =
        \\<blockquote>
        \\<p>bar</p>
        \\</blockquote>
        \\<p>baz</p>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// A consequence of the laziness rule is that any number of block quote markers may be omitted on a continuation of a nested quote.

// ```zig
test "5.1.15" {
    const input =
        \\> > > foo
        \\bar
    ;
    const output =
        \\<blockquote>
        \\<blockquote>
        \\<blockquote>
        \\<p>foo
        \\bar</p>
        \\</blockquote>
        \\</blockquote>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```

// ```zig
test "5.1.16" {
    const input =
        \\> > > foo
        \\> bar
        \\> > baz
    ;
    const output =
        \\<blockquote>
        \\<blockquote>
        \\<blockquote>
        \\<p>foo
        \\bar
        \\baz</p>
        \\</blockquote>
        \\</blockquote>
        \\</blockquote>
    ;
    try th.expectParseRMD(input, output);
}
// ```
